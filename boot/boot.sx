#define ASM_FILE        1
        
#include "multiboot.h"
     
/* C symbol format. HAVE_ASM_USCORE is defined by configure. */
#ifdef HAVE_ASM_USCORE
# define EXT_C(sym)                     _ ## sym
#else
# define EXT_C(sym)                     sym
#endif
     
/* The size of our stack (16KB). */
#define STACK_SIZE                      0x4000
     
/* The flags for the Multiboot header. */
#ifdef __ELF__
# define MULTIBOOT_HEADER_FLAGS         0x00000003
#else
# define MULTIBOOT_HEADER_FLAGS         0x00010003
#endif

#define CS_BASE 0x0FFFF0000
#define RAM_START   0x400
#define TSS_INDEX   10        

        
#define BIT_PE    0x01
#define DESC_SIZE 0x08
#define TEMP_TABLE_SIZE 0x02
#define LINEAR_SEL 1*DESC_SIZE
#define LINEAR_LO 0x0000FFFF
#define LINEAR_HI 0x000C9F00

        
.data
temp_gdt:
        /* NULL desc */
        .long 0
        .long 0
        
         /* linear desc*/
        .long LINEAR_LO
        .long LINEAR_HI
.bss
        .align 2
        .comm temp_gdt_scratch, 6
        .comm app_gdt_ram,  6
        .comm app_idt_ram,  6
        
data_segment_len:
        .long data_segmnet_size - temp_gdt

.text
.globl  _start
_start:
		jmp     multiboot_entry
        
			/* Align 32 bits boundary. */
		.align  4
        
/* Multiboot header. */
multiboot_header:
		/* magic */
        .long   MULTIBOOT_HEADER_MAGIC
        /* flags */
        .long   MULTIBOOT_HEADER_FLAGS
        /* checksum */
        .long   -(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS)
	#ifndef __ELF__
            /* header_addr */
        .long   multiboot_header
        /* load_addr */
        .long   _start
        /* load_end_addr */
        .long   _edata
        /* bss_end_addr */
        .long   _end
        /* entry_addr */
        .long   multiboot_entry
    #endif /* ! __ELF__ */
        
multiboot_entry:        
        /* Initialize the stack pointer. */
        movl    $(stack + STACK_SIZE), %esp
        
        /* Reset EFLAGS. */
        pushl   $0
        popf
        
        /* Push the pointer to the Multiboot information structure. */
        pushl   %ebx
        /* Push the magic value. */
        pushl   %eax
        
        /* Now enter the C main function... */
        call    EXT_C(cmain)

        /* load temp gdt */
        lea     temp_gdt, %ecx
        movl    $0,   (%ecx)
        movl    $0,   4(%ecx) 
        movl    $(LINEAR_LO), 8(%ecx)
        movl    $(LINEAR_HI),  12(%ecx)
            
        movl    $temp_gdt_scratch,    %ebx
        movw   $15, (%ebx)
        movl    %ecx, 2(%ebx)
        db 66h                  
        lgdt   temp_gdt_scratch
        
            /*Switch to protected mode */
        movl    %cr0,  %eax
        or      BIT_PE,  %eax
        movl    %eax,  %cr0
        jmp     protected_mode_entry
        
protected_mode_entry:
        movl    LINEAR_SEL, %ax
        movw    %ax,   %ds
        movw    %ax,   %es

        /*copy EPROM to ram */
        movl    $(RAM_START),   %eax
        addl    data_segment_len, %eax
        movl    $(RAM_START),   %ebx
        movl    $(CS_BASE), %ecx
        addl    $(GDT_EPROM_LEN),   %ecx
        
        movl    2(%ecx), %esi
        movl    %eax,   %edi
        movzx   (%ecx), %ecx
        movw    %cx,    app_gdt_ram
        inc     %ecx
        movl    %eax,   %edx
        movl    %eax,   app_gdt_ram(2,0,0)
        add     %ecx,   %eax
copy_eprom_gdt: 
        movls    %ds:%esi, %es:%edi
        loop    copy_eprom_gdt
        
        /* Halt. */
        pushl   $halt_message
        call    EXT_C(printf)
loop: hlt
            jmp     loop

halt_message:
        .asciz  "Halted."
     
            /* Our stack area. */
        .comm   stack, STACK_SIZE
        